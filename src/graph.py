from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
import sqlite3
from langchain_core.messages import AIMessage

from src.state import GatexState
from src.nodes.triage import triage_node
from src.nodes.knowledge import knowledge_node
from src.nodes.execution import execution_node

# --- Escalation / Endpoint Nodes ---

def human_escalation_node(state: GatexState):
    """
    Node for handling emergencies or fallback cases.
    """
    from src.llm_factory import get_llm
    from langchain_core.messages import SystemMessage
    
    llm = get_llm(temperature=0)
    urgency = state.get("urgency_score", 10)
    category = state.get("maintenance_category", "General")
    
    prompt = f"You are an Urgent Alert System. Generate a concise SMS alert for a Property Manager regarding a {category} emergency (Urgency: {urgency}/10). Start with 'ESCALATION TRIGGERED:'."
    
    response = llm.invoke([SystemMessage(content=prompt)] + state['messages'])
    
    msg = AIMessage(content=response.content)
    return {
        "messages": [msg],
        "resolution_strategy": "human_escalation"
    }

def human_approval_node(state: GatexState):
    """
    The 'Waiting Room' for human approval.
    In a real app, this might just be a state update, 
    but here it serves as a breakpoint before dispatch.
    """
    # This node executes AFTER the interrupt resumes (if approved)
    # OR it executes as the step leading up to the interrupt.
    # We'll use it to mark the status.
    return {"approval_status": False} # Reset or set status

def dispatch_node(state: GatexState):
    """
    Final node that 'sends' the email/work order.
    Only reached after approval.
    """
    vendor = state.get("selected_vendor")
    msg = AIMessage(content=f"DISPATCH CONFIRMED: Work order sent to {vendor['name'] if vendor else 'Vendor'}.")
    return {
        "messages": [msg],
        "resolution_strategy": "resolved"
    }

# --- New Nodes for Refined Flow ---

def wait_for_tenant_node(state: GatexState):
    """
    Breakpoint node for clarification.
    """
    # This node just serves as a marker to interrupt before.
    return {"status": "waiting_for_input"}

def send_guide_node(state: GatexState):
    """
    Handles DIY cases by sending a guide.
    """
    from src.llm_factory import get_llm
    from langchain_core.messages import SystemMessage
    
    llm = get_llm(temperature=0)
    
    # We could retrieve a specific guide from a vector store here, 
    # but for now we generate a polite response pointing to the portal.
    prompt = "You are a helpful Property Assistant. The tenant has a minor issue that is their responsibility. Politely explain this and provide this link for a guide: https://example.com/diy-guide. Be empathetic."
    
    response = llm.invoke([SystemMessage(content=prompt)] + state['messages'])
    
    msg = AIMessage(content=response.content)
    return {
        "messages": [msg],
        "resolution_strategy": "resolved"
    }

# --- Conditional Routers ---

def route_triage(state: GatexState):
    classification = state.get("classification")
    if classification == "emergency":
        return "human_escalation"
    elif classification == "clarification_needed":
        return "wait_for_tenant" # Ask the question generated by Triage
    else:
        return "knowledge" # Routine -> Check Policy

def route_knowledge(state: GatexState):
    strategy = state.get("resolution_strategy")
    if strategy == "diy":
        return "send_guide" # New path
    elif strategy == "decline":
        return END # Just stop (or send decline msg node)
    elif strategy == "clarify":
        return "wait_for_tenant" # Trigger interrupt
    elif strategy == "human_escalation":
        return "human_escalation"
    elif strategy == "vendor":
        return "execution" # Go to vendor search
    else:
        return END

# ... imports ...
from src.nodes.payment import payment_node

# ... existing code ...

def route_execution(state: GatexState):
    strategy = state.get("resolution_strategy")
    if strategy == "human_escalation":
        return "human_escalation"
    return "payment" # Go to payment negotiation

# ... existing code ...

# Add Nodes
workflow.add_node("triage", triage_node)
workflow.add_node("knowledge", knowledge_node)
workflow.add_node("execution", execution_node)
workflow.add_node("payment", payment_node) # New Node
workflow.add_node("human_escalation", human_escalation_node)
workflow.add_node("human_approval", human_approval_node)
workflow.add_node("dispatch", dispatch_node)
workflow.add_node("send_guide", send_guide_node)
workflow.add_node("wait_for_tenant", wait_for_tenant_node)

# ... existing code ...

workflow.add_conditional_edges(
    "execution",
    route_execution,
    {
        "human_escalation": "human_escalation",
        "payment": "payment"
    }
)

workflow.add_edge("payment", "wait_for_tenant")
workflow.add_edge("human_approval", "dispatch")
# ...

# Compile
import os
db_path = os.getenv("DB_PATH", "propflow.db")
conn = sqlite3.connect(db_path, check_same_thread=False)
checkpointer = SqliteSaver(conn)

app = workflow.compile(
    checkpointer=checkpointer,
    interrupt_before=["dispatch", "wait_for_tenant"] 
)
